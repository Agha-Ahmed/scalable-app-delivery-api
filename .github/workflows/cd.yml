name: CD

# Trigger this workflow after the CI workflow completes.
on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPO: scalable-api
  SERVICE_NAME: scalable-app-delivery-api

jobs:
  deploy:
    # Only run when CI finished successfully on main
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image variables
        id: vars
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
          IMAGE_URI="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}"
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push (buildx) with cache
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.IMAGE_URI }}:sha-${{ env.SHORT_SHA }}
            ${{ env.IMAGE_URI }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_ID=${{ env.SHORT_SHA }}
          labels: |
            org.opencontainers.image.revision=${{ env.SHORT_SHA }}

      - name: Deploy to App Runner (create or update)
        env:
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
        run: |
          SHORT_SHA="${{ env.SHORT_SHA }}"
          ACCOUNT_ID="${{ env.ACCOUNT_ID }}"
          IMAGE="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:sha-$SHORT_SHA"

          echo "Using image: $IMAGE"

          # Find existing service ARN (if any)
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='$SERVICE_NAME'].ServiceArn | [0]" --output text || echo "")

          # Build JSON for ImageRepository source configuration (App Runner)
          # Use single-quoted strings carefully for shell; pass to aws cli as a JSON string
          IMAGE_CONFIG=$(jq -c -n --arg img "$IMAGE" --arg port "3000" --arg build "$SHORT_SHA" '{
            ImageRepository: {
              ImageIdentifier: $img,
              ImageRepositoryType: "ECR",
              ImageConfiguration: {
                Port: $port,
                RuntimeEnvironmentVariables: [
                  { Name: "BUILD_ID", Value: $build }
                ]
              }
            }
          }')

          if [ -z "$SERVICE_ARN" ] || [ "$SERVICE_ARN" = "None" ]; then
            echo "Creating App Runner service..."
            aws apprunner create-service --service-name "$SERVICE_NAME" --source-configuration "$IMAGE_CONFIG"
          else
            echo "Updating App Runner service..."
            aws apprunner update-service --service-arn "$SERVICE_ARN" --source-configuration "$IMAGE_CONFIG"
          fi

      - name: Wait for service URL
        run: |
          # get service url (wait up to ~3 minutes)
          ATTEMPTS=30
          for i in $(seq 1 $ATTEMPTS); do
            SERVICE_URL=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.SERVICE_NAME }}'].ServiceUrl | [0]" --output text || echo "")
            if [ -n "$SERVICE_URL" ] && [ "$SERVICE_URL" != "None" ]; then
              echo "Service URL: $SERVICE_URL"
              echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
              exit 0
            fi
            echo "Waiting for App Runner service URL... ($i/$ATTEMPTS)"
            sleep 6
          done
          echo "Timed out waiting for service URL"
          exit 1

      - name: Smoke test deployed service (/version matches BUILD_ID)
        run: |
          SERVICE_URL="${{ env.SERVICE_URL }}"
          SHORT_SHA="${{ env.SHORT_SHA }}"
          echo "Service URL is $SERVICE_URL"
          for i in 1 12; do
            echo "Attempt $i: GET $SERVICE_URL/version"
            RES=$(curl -sS "$SERVICE_URL/version" || true)
            if echo "$RES" | grep -q "$SHORT_SHA"; then
              echo "Smoke test passed: /version contains $SHORT_SHA"
              exit 0
            fi
            sleep 5
          done
          echo "Smoke test failed: /version did not contain $SHORT_SHA"
          exit 1